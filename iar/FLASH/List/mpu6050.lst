###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       01/Aug/2018  12:09:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\mpu6050\mpu6050.c
#    Command line =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\mpu6050\mpu6050.c
#        -D LPLD_K60 -D USE_K60D10 -lCN
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List
#        -lB
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List
#        -o C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\ -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\camera\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\led\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\oled\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\task\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\uart\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\twinCore\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\mpu6050\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\nrf\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\calc\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\UI\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\ledArray\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\CPU\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\common\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\FatFs\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\common\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\driver\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\class\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List\mpu6050.lst
#    Object file  =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\Obj\mpu6050.o
#
###############################################################################

C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\mpu6050\mpu6050.c
      1          #include "MPU6050.h"
      2          
      3          /****Discription**********************************************/
      4          
      5          /*
      6          	0.需先调用mpu6050.Init()函数再使用本驱动
      7          	1.最好先调用mpu6050.SetOffset()来设置角速度零漂
      8          		获得零漂的方法为让陀螺仪静止，看内存中获得的GRY值
      9          	2.mpu6050.GetAcc/GetGry()函数为刷新相应的轴的值
     10          		参数为轴可以MPU6050_X | MPU6050_Y
     11          	3.访问mpu6050.acc.x可以获得x轴加速度的值
     12          
     13          	@Time	2018-04-25
     14          	@Author	郭帆
     15          	@Usefor	mpu6050
     16          */
     17          
     18          /****Definitions**********************************************/
     19          
     20          /****Functions************************************************/
     21          
     22          uint8 MPU6050_Init(void);
     23          uint8 MPU6050_GetAcc(uint16 accNum);
     24          uint8 MPU6050_GetGry(uint16 gryNum);
     25          void MPU6050_SetOffset(int16 x, int16 y, int16 z);
     26          
     27          uint8 MPU6050_SetACCFullScale(MPU6050_ACC_Fullscale_t fs);
     28          uint8 MPU6050_SetGRYFullScale(MPU6050_GRY_Fullscale_t fs);
     29          uint8 MPU6050_SetODR(MPU6050_ODR od);
     30          uint8 MPU6050_SetLPF(MPU6050_DLPF_t hz);
     31          uint8 MPU6050_SetMode(MPU6050_Status_t st);
     32          uint8 MPU6050_GetAcc_X(int16_t* raw);
     33          uint8 MPU6050_GetAcc_Y(int16_t* raw);
     34          uint8 MPU6050_GetAcc_Z(int16_t* raw);
     35          uint8 MPU6050_GetAngRateRaw_X(int16_t* raw);
     36          uint8 MPU6050_GetAngRateRaw_Y(int16_t* raw);
     37          uint8 MPU6050_GetAngRateRaw_Z(int16_t* raw);
     38          uint8 MPU6050_GetChipID(uint8_t* buff);
     39          
     40          /****Variables************************************************/
     41          
     42          /****Objects**************************************************/
     43          

   \                                 In section .data, align 4
     44          MPU6050_CLASS mpu6050 =
   \                     mpu6050:
   \   00000000   0x........         DC32 MPU6050_Init, MPU6050_GetAcc, MPU6050_GetGry, MPU6050_SetOffset
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x0000             DC16 0
   \   00000012   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000016   0x0000             DC16 0
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001C   0x0000             DC16 0
   \   0000001E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     45          {
     46          	&MPU6050_Init,
     47          	&MPU6050_GetAcc,
     48          	&MPU6050_GetGry,
     49          	&MPU6050_SetOffset,
     50          
     51          	{0}, {0}, {0}
     52          };
     53          
     54          /****Functions************************************************/
     55          

   \                                 In section .text, align 4, keep-with-next
     56          static void MPU6050_Delay(void)
     57          {
     58          	for (int i = 0; i < 1000; i++) asm("nop");
   \                     MPU6050_Delay: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE001             B.N      ??MPU6050_Delay_0
   \                     ??MPU6050_Delay_1: (+1)
   \   00000004   0xBF00             nop
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \                     ??MPU6050_Delay_0: (+1)
   \   00000008   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000000C   0xDBFA             BLT.N    ??MPU6050_Delay_1
     59          }
   \   0000000E   0x4770             BX       LR               ;; return
     60          

   \                                 In section .text, align 2, keep-with-next
     61          static uint8 MPU6050_Check(void)
     62          {
   \                     MPU6050_Check: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     63          	uint8 mpu6050ID = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
     64          
     65          	MPU6050_GetChipID(&mpu6050ID);
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       MPU6050_GetChipID
     66          
     67          	if (mpu6050ID != MPU6050_ID)
   \   0000000E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000012   0x2868             CMP      R0,#+104
   \   00000014   0xD001             BEQ.N    ??MPU6050_Check_0
     68          		return 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??MPU6050_Check_1
     69          
     70          	return 0;
   \                     ??MPU6050_Check_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_Check_1: (+1)
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          uint8 MPU6050_Init(void)
     74          {
   \                     MPU6050_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     75          	int result = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     76          
     77          	if (i2c.Init()) result = 1;
   \   00000004   0x....             LDR.N    R0,??DataTable6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD000             BEQ.N    ??MPU6050_Init_0
   \   0000000E   0x2401             MOVS     R4,#+1
     78          
     79          	MPU6050_Delay();
   \                     ??MPU6050_Init_0: (+1)
   \   00000010   0x.... 0x....      BL       MPU6050_Delay
     80          
     81          	if (MPU6050_Check()) result = 1;
   \   00000014   0x.... 0x....      BL       MPU6050_Check
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD000             BEQ.N    ??MPU6050_Init_1
   \   0000001C   0x2401             MOVS     R4,#+1
     82          
     83          	MPU6050_SetACCFullScale(MPU6050_ACC_FULLSCALE_4G);
   \                     ??MPU6050_Init_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       MPU6050_SetACCFullScale
     84          	MPU6050_SetGRYFullScale(MPU6050_GRY_FULLSCALE_500);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       MPU6050_SetGRYFullScale
     85          	MPU6050_SetODR(MPU6050_ODR_1000HZ);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       MPU6050_SetODR
     86          	MPU6050_SetLPF(MPU6050_DLPF_BW_42);
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x.... 0x....      BL       MPU6050_SetLPF
     87          	MPU6050_SetMode(MPU6050_ACTIVE);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       MPU6050_SetMode
     88          
     89          	return result;
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
     90          }
     91          

   \                                 In section .text, align 2, keep-with-next
     92          uint8 MPU6050_GetAcc(uint16 accNum)
     93          {
   \                     MPU6050_GetAcc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     94          	if (accNum & MPU6050_X) MPU6050_GetAcc_X(&mpu6050.acc.x);
   \   00000004   0x07E0             LSLS     R0,R4,#+31
   \   00000006   0xD502             BPL.N    ??MPU6050_GetAcc_0
   \   00000008   0x....             LDR.N    R0,??DataTable6_1
   \   0000000A   0x.... 0x....      BL       MPU6050_GetAcc_X
     95          	if (accNum & MPU6050_Y) MPU6050_GetAcc_Y(&mpu6050.acc.y);
   \                     ??MPU6050_GetAcc_0: (+1)
   \   0000000E   0x07A0             LSLS     R0,R4,#+30
   \   00000010   0xD502             BPL.N    ??MPU6050_GetAcc_1
   \   00000012   0x....             LDR.N    R0,??DataTable6_2
   \   00000014   0x.... 0x....      BL       MPU6050_GetAcc_Y
     96          	if (accNum & MPU6050_Z) MPU6050_GetAcc_Z(&mpu6050.acc.z);
   \                     ??MPU6050_GetAcc_1: (+1)
   \   00000018   0x0760             LSLS     R0,R4,#+29
   \   0000001A   0xD502             BPL.N    ??MPU6050_GetAcc_2
   \   0000001C   0x....             LDR.N    R0,??DataTable6_3
   \   0000001E   0x.... 0x....      BL       MPU6050_GetAcc_Z
     97          
     98          	return 0;
   \                     ??MPU6050_GetAcc_2: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          uint8 MPU6050_GetGry(uint16 gryNum)
    102          {
   \                     MPU6050_GetGry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    103          	if (gryNum & MPU6050_X)
   \   00000004   0x07E0             LSLS     R0,R4,#+31
   \   00000006   0xD52A             BPL.N    ??MPU6050_GetGry_0
    104          	{
    105          		MPU6050_GetAngRateRaw_X(&mpu6050.gry.x);
   \   00000008   0x....             LDR.N    R0,??DataTable6_4
   \   0000000A   0x.... 0x....      BL       MPU6050_GetAngRateRaw_X
    106          		mpu6050.gry.x = (int16)((float)mpu6050.gry.x / 65.5);
   \   0000000E   0x....             LDR.N    R0,??DataTable6_5
   \   00000010   0xF9B0 0x0016      LDRSH    R0,[R0, #+22]
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x.... 0x....      BL       __aeabi_f2d
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x....             LDR.N    R3,??DataTable6_6  ;; 0x40506000
   \   00000020   0x.... 0x....      BL       __aeabi_ddiv
   \   00000024   0x.... 0x....      BL       __aeabi_d2iz
   \   00000028   0x....             LDR.N    R1,??DataTable6_5
   \   0000002A   0x82C8             STRH     R0,[R1, #+22]
    107          		mpu6050.gry.x -= mpu6050.offset.x;
   \   0000002C   0x....             LDR.N    R0,??DataTable6_5
   \   0000002E   0x8AC0             LDRH     R0,[R0, #+22]
   \   00000030   0x....             LDR.N    R1,??DataTable6_5
   \   00000032   0x8B89             LDRH     R1,[R1, #+28]
   \   00000034   0x1A40             SUBS     R0,R0,R1
   \   00000036   0x....             LDR.N    R1,??DataTable6_5
   \   00000038   0x82C8             STRH     R0,[R1, #+22]
    108          		if (mpu6050.pose.flagX && !mpu6050.pose.pause /*&& abs(mpu6050.gry.x) > 10*/) mpu6050.pose.angleX += mpu6050.gry.x;
   \   0000003A   0x....             LDR.N    R0,??DataTable6_5
   \   0000003C   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   00000040   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD10A             BNE.N    ??MPU6050_GetGry_0
   \   00000048   0x....             LDR.N    R0,??DataTable6_5
   \   0000004A   0xF9B0 0x0016      LDRSH    R0,[R0, #+22]
   \   0000004E   0x.... 0x....      BL       __aeabi_i2f
   \   00000052   0x....             LDR.N    R1,??DataTable6_5
   \   00000054   0x6A49             LDR      R1,[R1, #+36]
   \   00000056   0x.... 0x....      BL       __aeabi_fadd
   \   0000005A   0x....             LDR.N    R1,??DataTable6_5
   \   0000005C   0x6248             STR      R0,[R1, #+36]
    109          	}
    110          	if (gryNum & MPU6050_Y)
   \                     ??MPU6050_GetGry_0: (+1)
   \   0000005E   0x07A0             LSLS     R0,R4,#+30
   \   00000060   0xD531             BPL.N    ??MPU6050_GetGry_1
    111          	{
    112          		MPU6050_GetAngRateRaw_Y(&mpu6050.gry.y);
   \   00000062   0x....             LDR.N    R0,??DataTable6_7
   \   00000064   0x.... 0x....      BL       MPU6050_GetAngRateRaw_Y
    113          		mpu6050.gry.y = (int16)((float)mpu6050.gry.y / 65.5);
   \   00000068   0x....             LDR.N    R0,??DataTable6_5
   \   0000006A   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   0000006E   0x.... 0x....      BL       __aeabi_i2f
   \   00000072   0x.... 0x....      BL       __aeabi_f2d
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x....             LDR.N    R3,??DataTable6_6  ;; 0x40506000
   \   0000007A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0x....             LDR.N    R1,??DataTable6_5
   \   00000084   0x8308             STRH     R0,[R1, #+24]
    114          		mpu6050.gry.y -= mpu6050.offset.y;
   \   00000086   0x....             LDR.N    R0,??DataTable6_5
   \   00000088   0x8B00             LDRH     R0,[R0, #+24]
   \   0000008A   0x....             LDR.N    R1,??DataTable6_5
   \   0000008C   0x8BC9             LDRH     R1,[R1, #+30]
   \   0000008E   0x1A40             SUBS     R0,R0,R1
   \   00000090   0x....             LDR.N    R1,??DataTable6_5
   \   00000092   0x8308             STRH     R0,[R1, #+24]
    115          		if (mpu6050.pose.flagY && !mpu6050.pose.pause && abs(mpu6050.gry.y) > 10) mpu6050.pose.angleY += mpu6050.gry.y;
   \   00000094   0x....             LDR.N    R0,??DataTable6_5
   \   00000096   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   0000009A   0xF010 0x000A      ANDS     R0,R0,#0xA
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD111             BNE.N    ??MPU6050_GetGry_1
   \   000000A2   0x....             LDR.N    R0,??DataTable6_5
   \   000000A4   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   000000A8   0x.... 0x....      BL       abs
   \   000000AC   0x280B             CMP      R0,#+11
   \   000000AE   0xDB0A             BLT.N    ??MPU6050_GetGry_1
   \   000000B0   0x....             LDR.N    R0,??DataTable6_5
   \   000000B2   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   000000B6   0x.... 0x....      BL       __aeabi_i2f
   \   000000BA   0x....             LDR.N    R1,??DataTable6_5
   \   000000BC   0x6A89             LDR      R1,[R1, #+40]
   \   000000BE   0x.... 0x....      BL       __aeabi_fadd
   \   000000C2   0x....             LDR.N    R1,??DataTable6_5
   \   000000C4   0x6288             STR      R0,[R1, #+40]
    116          	}
    117          	if (gryNum & MPU6050_Z)
   \                     ??MPU6050_GetGry_1: (+1)
   \   000000C6   0x0760             LSLS     R0,R4,#+29
   \   000000C8   0xD52A             BPL.N    ??MPU6050_GetGry_2
    118          	{
    119          		MPU6050_GetAngRateRaw_Z(&mpu6050.gry.z);
   \   000000CA   0x....             LDR.N    R0,??DataTable6_8
   \   000000CC   0x.... 0x....      BL       MPU6050_GetAngRateRaw_Z
    120          		mpu6050.gry.z = (int16)((float)mpu6050.gry.z / 65.5);
   \   000000D0   0x....             LDR.N    R0,??DataTable6_5
   \   000000D2   0xF9B0 0x001A      LDRSH    R0,[R0, #+26]
   \   000000D6   0x.... 0x....      BL       __aeabi_i2f
   \   000000DA   0x.... 0x....      BL       __aeabi_f2d
   \   000000DE   0x2200             MOVS     R2,#+0
   \   000000E0   0x....             LDR.N    R3,??DataTable6_6  ;; 0x40506000
   \   000000E2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000E6   0x.... 0x....      BL       __aeabi_d2iz
   \   000000EA   0x....             LDR.N    R1,??DataTable6_5
   \   000000EC   0x8348             STRH     R0,[R1, #+26]
    121          		mpu6050.gry.z -= mpu6050.offset.z;
   \   000000EE   0x....             LDR.N    R0,??DataTable6_5
   \   000000F0   0x8B40             LDRH     R0,[R0, #+26]
   \   000000F2   0x....             LDR.N    R1,??DataTable6_5
   \   000000F4   0x8C09             LDRH     R1,[R1, #+32]
   \   000000F6   0x1A40             SUBS     R0,R0,R1
   \   000000F8   0x....             LDR.N    R1,??DataTable6_5
   \   000000FA   0x8348             STRH     R0,[R1, #+26]
    122          		if (mpu6050.pose.flagZ && !mpu6050.pose.pause /*&& abs(mpu6050.gry.z) > 10*/) mpu6050.pose.angleZ += mpu6050.gry.z;
   \   000000FC   0x....             LDR.N    R0,??DataTable6_5
   \   000000FE   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   00000102   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000106   0x2804             CMP      R0,#+4
   \   00000108   0xD10A             BNE.N    ??MPU6050_GetGry_2
   \   0000010A   0x....             LDR.N    R0,??DataTable6_5
   \   0000010C   0xF9B0 0x001A      LDRSH    R0,[R0, #+26]
   \   00000110   0x.... 0x....      BL       __aeabi_i2f
   \   00000114   0x....             LDR.N    R1,??DataTable6_5
   \   00000116   0x6AC9             LDR      R1,[R1, #+44]
   \   00000118   0x.... 0x....      BL       __aeabi_fadd
   \   0000011C   0x....             LDR.N    R1,??DataTable6_5
   \   0000011E   0x62C8             STR      R0,[R1, #+44]
    123          	}
    124          
    125          	return 0;
   \                     ??MPU6050_GetGry_2: (+1)
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xBD10             POP      {R4,PC}          ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          void MPU6050_SetOffset(int16 x, int16 y, int16 z)
    129          {
    130          	mpu6050.offset.x = x;
   \                     MPU6050_SetOffset: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable6_5
   \   00000002   0x8398             STRH     R0,[R3, #+28]
    131          	mpu6050.offset.y = y;
   \   00000004   0x....             LDR.N    R0,??DataTable6_5
   \   00000006   0x83C1             STRH     R1,[R0, #+30]
    132          	mpu6050.offset.z = z;
   \   00000008   0x....             LDR.N    R0,??DataTable6_5
   \   0000000A   0x8402             STRH     R2,[R0, #+32]
    133          }
   \   0000000C   0x4770             BX       LR               ;; return
    134          

   \                                 In section .text, align 2, keep-with-next
    135          uint8_t MPU6050_ReadReg(uint8_t Reg, uint8_t* Data)
    136          {
   \                     MPU6050_ReadReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    137          	//To be completed with either I2c or SPI reading function
    138          	//i.e.: *Data = SPI_Mems_Read_Reg( Reg );
    139          	*Data = i2c.ReadReg(MPU6050_SlaveAddress, Reg);
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2068             MOVS     R0,#+104
   \   0000000A   0x....             LDR.N    R2,??DataTable6
   \   0000000C   0x6852             LDR      R2,[R2, #+4]
   \   0000000E   0x4790             BLX      R2
   \   00000010   0x7020             STRB     R0,[R4, #+0]
    140          	return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    141          }
    142          

   \                                 In section .text, align 2, keep-with-next
    143          int16_t MPU6050_ReadWord(uint8_t Reg, int16_t* Data)
    144          {
   \                     MPU6050_ReadWord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    145          	//To be completed with either I2c or SPI reading function
    146          	//i.e.: *Data = SPI_Mems_Read_Reg( Reg );
    147          	*Data = i2c.ReadWord(MPU6050_SlaveAddress, Reg,MSB_FIRST);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2068             MOVS     R0,#+104
   \   0000000C   0x....             LDR.N    R3,??DataTable6
   \   0000000E   0x689B             LDR      R3,[R3, #+8]
   \   00000010   0x4798             BLX      R3
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    148          	return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    149          }
    150          

   \                                 In section .text, align 2, keep-with-next
    151          uint8_t MPU6050_WriteReg(uint8_t Reg, uint8_t Data)
    152          {
   \                     MPU6050_WriteReg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    153          	//To be completed with either I2c or SPI writing function
    154          	//i.e.: SPI_Mems_Write_Reg(Reg, Data);
    155          	i2c.WriteReg(MPU6050_SlaveAddress, Reg, Data);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2068             MOVS     R0,#+104
   \   0000000C   0x....             LDR.N    R3,??DataTable6
   \   0000000E   0x68DB             LDR      R3,[R3, #+12]
   \   00000010   0x4798             BLX      R3
    156          	return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          uint8 MPU6050_SetClockSource()
    160          {
    161          	return 0;
   \                     MPU6050_SetClockSource: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          uint8 MPU6050_SetACCFullScale(MPU6050_ACC_Fullscale_t fs)
    165          {
   \                     MPU6050_SetACCFullScale: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    166          	if (!MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, fs))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x201C             MOVS     R0,#+28
   \   00000008   0x.... 0x....      BL       MPU6050_WriteReg
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MPU6050_SetACCFullScale_0
    167          		return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??MPU6050_SetACCFullScale_1
    168          
    169          	return 0;
   \                     ??MPU6050_SetACCFullScale_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_SetACCFullScale_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    170          }
    171          

   \                                 In section .text, align 2, keep-with-next
    172          uint8 MPU6050_SetGRYFullScale(MPU6050_GRY_Fullscale_t fs)
    173          {
   \                     MPU6050_SetGRYFullScale: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    174          	if (!MPU6050_WriteReg(MPU6050_GYRO_CONFIG, fs))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x201B             MOVS     R0,#+27
   \   00000008   0x.... 0x....      BL       MPU6050_WriteReg
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MPU6050_SetGRYFullScale_0
    175          		return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??MPU6050_SetGRYFullScale_1
    176          
    177          	return 0;
   \                     ??MPU6050_SetGRYFullScale_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_SetGRYFullScale_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          uint8 MPU6050_SetODR(MPU6050_ODR od)
    181          {
   \                     MPU6050_SetODR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    182          	if (!MPU6050_WriteReg(MPU6050_SMPLRT_DIV, od))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2019             MOVS     R0,#+25
   \   00000008   0x.... 0x....      BL       MPU6050_WriteReg
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MPU6050_SetODR_0
    183          		return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??MPU6050_SetODR_1
    184          
    185          	return 0;
   \                     ??MPU6050_SetODR_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_SetODR_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          uint8 MPU6050_SetLPF(MPU6050_DLPF_t hz)
    189          {
   \                     MPU6050_SetLPF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    190          	if (!MPU6050_WriteReg(MPU6050_CONFIG, hz))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x201A             MOVS     R0,#+26
   \   00000008   0x.... 0x....      BL       MPU6050_WriteReg
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MPU6050_SetLPF_0
    191          		return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??MPU6050_SetLPF_1
    192          
    193          	return 0;
   \                     ??MPU6050_SetLPF_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_SetLPF_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          uint8 MPU6050_SetMode(MPU6050_Status_t st)
    197          {
   \                     MPU6050_SetMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    198          	if (!MPU6050_WriteReg(MPU6050_PWR_MGMT_1, st))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x206B             MOVS     R0,#+107
   \   00000008   0x.... 0x....      BL       MPU6050_WriteReg
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??MPU6050_SetMode_0
    199          		return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??MPU6050_SetMode_1
    200          
    201          	return 0;
   \                     ??MPU6050_SetMode_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_SetMode_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    202          }
    203          

   \                                 In section .text, align 2, keep-with-next
    204          uint8 MPU6050_GetAcc_X(int16_t *raw)
    205          {
   \                     MPU6050_GetAcc_X: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    206          #if USE_SEQ_READ
    207          	MPU6050_ReadWord(MPU6050_ACCEL_XOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x203B             MOVS     R0,#+59
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    208          #else
    209          	uint8_t valueL;
    210          	uint8_t valueH;
    211          	if (!MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L, &valueL))
    212          		return 1;
    213          	if (!MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H, &valueH))
    214          		return 1;
    215          	*raw = (int16_t)((valueH << 8) | valueL);
    216          #endif
    217          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    218          }
    219          

   \                                 In section .text, align 2, keep-with-next
    220          uint8 MPU6050_GetAcc_Y(int16_t *raw)
    221          {
   \                     MPU6050_GetAcc_Y: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    222          #if USE_SEQ_READ
    223          	MPU6050_ReadWord(MPU6050_ACCEL_YOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x203D             MOVS     R0,#+61
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    224          #else
    225          	uint8_t valueL;
    226          	uint8_t valueH;
    227          	if (!MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L, &valueL))
    228          		return 1;
    229          	if (!MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H, &valueH))
    230          		return 1;
    231          	*raw = (int16_t)((valueH << 8) | valueL);
    232          #endif
    233          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          uint8 MPU6050_GetAcc_Z(int16_t *raw)
    237          {
   \                     MPU6050_GetAcc_Z: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    238          #if USE_SEQ_READ
    239          	MPU6050_ReadWord(MPU6050_ACCEL_ZOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x203F             MOVS     R0,#+63
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    240          #else
    241          	uint8_t valueL;
    242          	uint8_t valueH;
    243          	if (!MEMS_MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L, &valueL))
    244          		return 1;
    245          	if (!MEMS_MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H, &valueH))
    246          		return 1;
    247          	*raw = (int16_t)((valueH << 8) | valueL);
    248          #endif
    249          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    250          }
    251          

   \                                 In section .text, align 2, keep-with-next
    252          uint8 MPU6050_GetAngRateRaw_X(int16_t *raw)
    253          {
   \                     MPU6050_GetAngRateRaw_X: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    254          #if USE_SEQ_READ
    255          	MPU6050_ReadWord(MPU6050_GYRO_XOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x2043             MOVS     R0,#+67
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    256          #else
    257          	uint8_t valueL;
    258          	uint8_t valueH;
    259          	if (!MPU6050_ReadReg(MPU6050_GYRO_XOUT_L, &valueL))
    260          		return 1;
    261          	if (!MPU6050_ReadReg(MPU6050_GYRO_XOUT_H, &valueH))
    262          		return 1;
    263          	*raw = (int16_t)((valueH << 8) | valueL);
    264          #endif
    265          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          uint8 MPU6050_GetAngRateRaw_Y(int16_t *raw)
    269          {
   \                     MPU6050_GetAngRateRaw_Y: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    270          #if USE_SEQ_READ
    271          	MPU6050_ReadWord(MPU6050_GYRO_YOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x2045             MOVS     R0,#+69
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    272          #else
    273          	uint8_t valueL;
    274          	uint8_t valueH;
    275          	if (!MPU6050_ReadReg(MPU6050_GYRO_YOUT_L, &valueL))
    276          		return 1;
    277          	if (!MPU6050_ReadReg(MPU6050_GYRO_YOUT_H, &valueH))
    278          		return 1;
    279          	*raw = (int16_t)((valueH << 8) | valueL);
    280          #endif
    281          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    282          }
    283          

   \                                 In section .text, align 2, keep-with-next
    284          uint8 MPU6050_GetAngRateRaw_Z(int16_t *raw)
    285          {
   \                     MPU6050_GetAngRateRaw_Z: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    286          #if USE_SEQ_READ
    287          	MPU6050_ReadWord(MPU6050_GYRO_ZOUT_H, raw);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x2047             MOVS     R0,#+71
   \   00000006   0x.... 0x....      BL       MPU6050_ReadWord
    288          #else
    289          	uint8_t valueL;
    290          	uint8_t valueH;
    291          	if (!MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L, &valueL))
    292          		return 1;
    293          	if (!MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H, &valueH))
    294          		return 1;
    295          	*raw = (int16_t)((valueH << 8) | valueL);
    296          #endif
    297          	return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    298          }
    299          

   \                                 In section .text, align 2, keep-with-next
    300          uint8 MPU6050_GetChipID(uint8_t *buff)
    301          {
   \                     MPU6050_GetChipID: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    302          	if (!MPU6050_ReadReg(MPU6050_WHO_AM_I, buff))
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x200F             MOVS     R0,#+15
   \   00000006   0x.... 0x....      BL       MPU6050_ReadReg
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??MPU6050_GetChipID_0
    303          		return 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??MPU6050_GetChipID_1
    304          
    305          	return 0;
   \                     ??MPU6050_GetChipID_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_GetChipID_1: (+1)
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    306          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     i2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     mpu6050+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     mpu6050+0x12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     mpu6050+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     mpu6050+0x16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     mpu6050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40506000         DC32     0x40506000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     mpu6050+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     mpu6050+0x1A

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   MPU6050_Check
         8   -> MPU6050_GetChipID
       0   MPU6050_Delay
       8   MPU6050_GetAcc
         8   -> MPU6050_GetAcc_X
         8   -> MPU6050_GetAcc_Y
         8   -> MPU6050_GetAcc_Z
       8   MPU6050_GetAcc_X
         8   -> MPU6050_ReadWord
       8   MPU6050_GetAcc_Y
         8   -> MPU6050_ReadWord
       8   MPU6050_GetAcc_Z
         8   -> MPU6050_ReadWord
       8   MPU6050_GetAngRateRaw_X
         8   -> MPU6050_ReadWord
       8   MPU6050_GetAngRateRaw_Y
         8   -> MPU6050_ReadWord
       8   MPU6050_GetAngRateRaw_Z
         8   -> MPU6050_ReadWord
       8   MPU6050_GetChipID
         8   -> MPU6050_ReadReg
       8   MPU6050_GetGry
         8   -> MPU6050_GetAngRateRaw_X
         8   -> MPU6050_GetAngRateRaw_Y
         8   -> MPU6050_GetAngRateRaw_Z
         8   -> __aeabi_d2iz
         8   -> __aeabi_ddiv
         8   -> __aeabi_f2d
         8   -> __aeabi_fadd
         8   -> __aeabi_i2f
         8   -> abs
       8   MPU6050_Init
         8   -- Indirect call
         8   -> MPU6050_Check
         8   -> MPU6050_Delay
         8   -> MPU6050_SetACCFullScale
         8   -> MPU6050_SetGRYFullScale
         8   -> MPU6050_SetLPF
         8   -> MPU6050_SetMode
         8   -> MPU6050_SetODR
       8   MPU6050_ReadReg
         8   -- Indirect call
       8   MPU6050_ReadWord
         8   -- Indirect call
       8   MPU6050_SetACCFullScale
         8   -> MPU6050_WriteReg
       0   MPU6050_SetClockSource
       8   MPU6050_SetGRYFullScale
         8   -> MPU6050_WriteReg
       8   MPU6050_SetLPF
         8   -> MPU6050_WriteReg
       8   MPU6050_SetMode
         8   -> MPU6050_WriteReg
       8   MPU6050_SetODR
         8   -> MPU6050_WriteReg
       0   MPU6050_SetOffset
       8   MPU6050_WriteReg
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      30  MPU6050_Check
      16  MPU6050_Delay
      38  MPU6050_GetAcc
      14  MPU6050_GetAcc_X
      14  MPU6050_GetAcc_Y
      14  MPU6050_GetAcc_Z
      14  MPU6050_GetAngRateRaw_X
      14  MPU6050_GetAngRateRaw_Y
      14  MPU6050_GetAngRateRaw_Z
      22  MPU6050_GetChipID
     292  MPU6050_GetGry
      66  MPU6050_Init
      22  MPU6050_ReadReg
      24  MPU6050_ReadWord
      24  MPU6050_SetACCFullScale
       4  MPU6050_SetClockSource
      24  MPU6050_SetGRYFullScale
      24  MPU6050_SetLPF
      24  MPU6050_SetMode
      24  MPU6050_SetODR
      14  MPU6050_SetOffset
      22  MPU6050_WriteReg
      52  mpu6050

 
  52 bytes in section .data
 790 bytes in section .text
 
 790 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
