###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       01/Aug/2018  12:09:49
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\nrf\nrf.c
#    Command line =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\nrf\nrf.c -D
#        LPLD_K60 -D USE_K60D10 -lCN
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List
#        -lB
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List
#        -o C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\ -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\camera\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\led\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\oled\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\task\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\uart\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\twinCore\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\mpu6050\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\nrf\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\calc\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\UI\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\app\ledArray\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\CPU\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\common\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\FatFs\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\common\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\driver\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\..\lib\USB\class\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\List\nrf.lst
#    Object file  =  
#        C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\iar\FLASH\Obj\nrf.o
#
###############################################################################

C:\Users\ShowD\Desktop\LPHD\LPHD_camCore\LPHD_camCore\app\nrf\nrf.c
      1          #include "nrf.h"
      2          
      3          /****Discription**********************************************/
      4          
      5          /*
      6          	0.与另一辆车进行通讯，引脚输入接输出
      7          	1.需先调用nrf.Init()函数再使用本驱动
      8          	2.调用nrf.Send()可以将nrf.tx_buf数组的内容传输出去
      9          	3.调用nrf.Set(uint8, int16)函数可以对相应的通道数据进行更改
     10          	4.nrf.data数组将会自动更新，
     11          		但是可以在本文件的NRF_isr函数中对对应的数据进行判断
     12          
     13          	@Time	2018-04-27
     14          	@Author	郭帆
     15          	@Usefor	双车通讯
     16          */
     17          
     18          /****Variables************************************************/
     19          

   \                                 In section .data, align 4
     20          uint8 TX_ADDRESS[NRF_TX_ADR_LEN] = NRF_TX_ADDRESS; //发送地址
   \                     TX_ADDRESS:
   \   00000000   0xDF 0xFD          DC8 223, 253, 16, 16, 1, 0, 0, 0
   \              0x10 0x10    
   \              0x01 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     21          uint8 RX_ADDRESS[NRF_RX_ADR_LEN] = NRF_RX_ADDRESS; //接收地址(本机地址,仅用于接收模式)
   \                     RX_ADDRESS:
   \   00000000   0xDF 0xFD          DC8 223, 253, 16, 16, 1, 0, 0, 0
   \              0x10 0x10    
   \              0x01 0x00    
   \              0x00 0x00    
     22          //NRF24L01复位之后用于检测
     23          // NRF24L01_RX_ADDR_P0的复位值是否为0xE7E7E7E7
     24          // NRF24L01_RX_ADDR_P1的复位值是否为0xC2C2C2C2
     25          // NRF24L01_TX_ADDR的复位值是否为0xE7E7E7E7

   \                                 In section .bss, align 4
     26          uint8 NRF_RX_ADDR_P0_RESET_BUF1[5], NRF_RX_ADDR_P0_RESET_BUF2[5];
   \                     NRF_RX_ADDR_P0_RESET_BUF1:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \                     NRF_RX_ADDR_P0_RESET_BUF2:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     27          uint8 NRF_RX_ADDR_P1_RESET_BUF1[5], NRF_RX_ADDR_P1_RESET_BUF2[5];
   \                     NRF_RX_ADDR_P1_RESET_BUF1:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \                     NRF_RX_ADDR_P1_RESET_BUF2:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     28          uint8 NRF_TX_ADDR_RESET_BUF1[5], NRF_TX_ADDR_RESET_BUF2[5];
   \                     NRF_TX_ADDR_RESET_BUF1:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \                     NRF_TX_ADDR_RESET_BUF2:
   \   00000000                      DS8 8
     29          
     30          /****Function list********************************************/
     31          
     32          static uint8 LPLD_NRF_CheckID(SPI_Type *spix);
     33          static uint8 LPLD_NRF_WriteBuf(SPI_Type *spix, uint8 reg, uint8 *pbuf, uint8 len);
     34          static uint8 LPLD_NRF_ReadBuf(SPI_Type *spix, uint8 reg, uint8 *pbuf, uint8 len);
     35          static uint8 LPLD_NRF_WriteReg(SPI_Type *spix, uint8 reg, uint8 value);
     36          static uint8 LPLD_NRF_ReadReg(SPI_Type *spix, uint8 reg);
     37          static void Nrf24L01_DelayUs(uint16 t);
     38          uint8 LPLD_NRF_TX_SendFrame(uint8 *data, uint8 len);
     39          void LPLD_NRF_RX_RecvFrame(uint8 *data, uint8 len);
     40          
     41          void NRF_isr(void);
     42          void NRF_Init(void);
     43          void NRF_Set(uint8 index, uint8 data);
     44          void NRF_Send(void);
     45          
     46          /****Objects**************************************************/
     47          

   \                                 In section .data, align 4
     48          NRF_CLASS nrf =
   \                     nrf:
   \   00000000   0x........         DC32 NRF_Init, NRF_Set, NRF_Send
   \              0x........   
   \              0x........   
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000002D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000003D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
     49          {
     50          	&NRF_Init,
     51          	&NRF_Set,
     52          	&NRF_Send,
     53          
     54          	{0}, {0}
     55          };
     56          
     57          /****Functions************************************************/
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void NRF_isr(void)
     60          {
   \                     NRF_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     61          	if (LPLD_GPIO_IsPinxExt(NRF_RX_IRQ_PORT, NRF_RX_IRQ_Pinx))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400490a0
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0540             LSLS     R0,R0,#+21
   \   0000000A   0xD504             BPL.N    ??NRF_isr_0
     62          		LPLD_NRF_RX_RecvFrame(nrf.data, NRF_PLOAD_LEN);
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000012   0x.... 0x....      BL       LPLD_NRF_RX_RecvFrame
     63          }
   \                     ??NRF_isr_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
     64          

   \                                 In section .text, align 2, keep-with-next
     65          uint8 LPLD_NRF_TX_SendFrame(uint8 *data, uint8 len)
     66          {
   \                     LPLD_NRF_TX_SendFrame: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
     67          	uint8 Status;
     68          	int  time = 0;
   \   00000006   0x2400             MOVS     R4,#+0
     69          
     70          	NRF_TX_CE_L(); //拉低CE，让Nrf24l01进入Standby-I模式
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe1828
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     71          
     72          	LPLD_NRF_WriteBuf(NRF_TX_SPIx, NRF_WRITE_REG + NRF_RX_ADDR_P0, TX_ADDRESS, NRF_RX_ADR_LEN); // 装载接收端地址
   \   00000010   0x2305             MOVS     R3,#+5
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable9_3
   \   00000016   0x212A             MOVS     R1,#+42
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   0000001C   0x.... 0x....      BL       LPLD_NRF_WriteBuf
     73          	LPLD_NRF_WriteBuf(NRF_TX_SPIx, NRF_WR_TX_PLOAD, data, len); 			   // 装载数据
   \   00000020   0x0033             MOVS     R3,R6
   \   00000022   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000024   0x002A             MOVS     R2,R5
   \   00000026   0x21A0             MOVS     R1,#+160
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   0000002C   0x.... 0x....      BL       LPLD_NRF_WriteBuf
     74          	LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_CONFIG, 0x0E);      //使能CRC校验，使能TX，并且上电
   \   00000030   0x220E             MOVS     R2,#+14
   \   00000032   0x2120             MOVS     R1,#+32
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   00000038   0x.... 0x....      BL       LPLD_NRF_WriteReg
     75          
     76          	NRF_TX_CE_H();
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe1828
   \   00000042   0x6008             STR      R0,[R1, #+0]
     77          
     78          	while (1)
     79          	{
     80          		Status = LPLD_NRF_ReadReg(NRF_TX_SPIx, NRF_STATUS);           //读取状态寄存器
   \                     ??LPLD_NRF_TX_SendFrame_0: (+1)
   \   00000044   0x2107             MOVS     R1,#+7
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   0000004A   0x.... 0x....      BL       LPLD_NRF_ReadReg
   \   0000004E   0x0005             MOVS     R5,R0
     81          		LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_STATUS, Status);  //清空状态奇存器
   \   00000050   0x002A             MOVS     R2,R5
   \   00000052   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000054   0x2127             MOVS     R1,#+39
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   0000005A   0x.... 0x....      BL       LPLD_NRF_WriteReg
     82          		if (Status & NRF_STATUS_TX_DS)                //如果发送完毕，并接收到ACK，该标志位置位
   \   0000005E   0x06A8             LSLS     R0,R5,#+26
   \   00000060   0xD507             BPL.N    ??LPLD_NRF_TX_SendFrame_1
     83          		{
     84          			LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_FLUSE_TX, 0xFF); //清空发送缓冲区
   \   00000062   0x22FF             MOVS     R2,#+255
   \   00000064   0x21E1             MOVS     R1,#+225
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400ac000
   \   0000006A   0x.... 0x....      BL       LPLD_NRF_WriteReg
     85          			Status = 1;
   \   0000006E   0x2501             MOVS     R5,#+1
     86          			break;
   \   00000070   0xE00A             B.N      ??LPLD_NRF_TX_SendFrame_2
     87          		}
     88          		else if (Status & NRF_STATUS_MAX_RT)//如果达到多次发送的最大值，且期间没有接收到ACK
   \                     ??LPLD_NRF_TX_SendFrame_1: (+1)
   \   00000072   0x06E8             LSLS     R0,R5,#+27
   \   00000074   0xD501             BPL.N    ??LPLD_NRF_TX_SendFrame_3
     89          		{
     90          			Status = 0;
   \   00000076   0x2500             MOVS     R5,#+0
     91          			break;
   \   00000078   0xE006             B.N      ??LPLD_NRF_TX_SendFrame_2
     92          		}
     93          
     94          		time++;
   \                     ??LPLD_NRF_TX_SendFrame_3: (+1)
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
     95          		LPLD_SYSTICK_DelayUs(10);
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0x.... 0x....      BL       LPLD_SYSTICK_DelayUs
     96          		if (time > 200)
   \   00000082   0x2CC9             CMP      R4,#+201
   \   00000084   0xDBDE             BLT.N    ??LPLD_NRF_TX_SendFrame_0
     97          		{
     98          			Status = 0;
   \   00000086   0x2500             MOVS     R5,#+0
     99          			break;
    100          		}
    101          	}
    102          	return Status;
   \                     ??LPLD_NRF_TX_SendFrame_2: (+1)
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
    103          }
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void LPLD_NRF_RX_RecvFrame(uint8 *data, uint8 len)
    106          {
   \                     LPLD_NRF_RX_RecvFrame: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    107          	uint8 Status;
    108          	Status = LPLD_NRF_ReadReg(NRF_RX_SPIx, NRF_STATUS);
   \   00000006   0x2107             MOVS     R1,#+7
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4002c000
   \   0000000C   0x.... 0x....      BL       LPLD_NRF_ReadReg
   \   00000010   0x0006             MOVS     R6,R0
    109          	LPLD_NRF_ReadBuf(NRF_RX_SPIx, NRF_RD_RX_PLOAD, data, len);
   \   00000012   0x002B             MOVS     R3,R5
   \   00000014   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000016   0x0022             MOVS     R2,R4
   \   00000018   0x2161             MOVS     R1,#+97
   \   0000001A   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000001C   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    110          	LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_STATUS, Status);
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x2127             MOVS     R1,#+39
   \   00000026   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   00000028   0x.... 0x....      BL       LPLD_NRF_WriteReg
    111          	Status = 0;
   \   0000002C   0x2600             MOVS     R6,#+0
    112          }
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    113          

   \                                 In section .text, align 2, keep-with-next
    114          void NRF_Set(uint8 index, uint8 data)
    115          {
    116          	if (index < NRF_PLOAD_LEN)
   \                     NRF_Set: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2820             CMP      R0,#+32
   \   00000004   0xDA04             BGE.N    ??NRF_Set_0
    117          		nrf.tx_buf[index] = data;
   \   00000006   0x....             LDR.N    R2,??DataTable9_6
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x1880             ADDS     R0,R0,R2
   \   0000000C   0xF880 0x102C      STRB     R1,[R0, #+44]
    118          }
   \                     ??NRF_Set_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void NRF_Send(void)
    121          {
   \                     NRF_Send: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    122          	LPLD_NRF_TX_SendFrame(nrf.tx_buf, NRF_PLOAD_LEN);
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0x....             LDR.N    R0,??DataTable9_7
   \   00000006   0x.... 0x....      BL       LPLD_NRF_TX_SendFrame
    123          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    124          

   \                                 In section .text, align 2, keep-with-next
    125          static void NRF_SPI_Init(void)
    126          {
   \                     NRF_SPI_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    127          	static SPI_InitTypeDef SPI_InitStructure;
    128          	static GPIO_InitTypeDef GPIO_InitStructure;
    129          
    130          	// 初始化发送模块SPI
    131          	SPI_InitStructure.SPI_SPIx = NRF_TX_SPIx;
   \   00000004   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   00000006   0x....             LDR.N    R1,??DataTable9_8
   \   00000008   0x6008             STR      R0,[R1, #+0]
    132          	SPI_InitStructure.SPI_SckDivider = SPI_SCK_DIV_32;
   \   0000000A   0x2005             MOVS     R0,#+5
   \   0000000C   0x....             LDR.N    R1,??DataTable9_8
   \   0000000E   0x7148             STRB     R0,[R1, #+5]
    133          	SPI_InitStructure.SPI_Pcs0Pin = NRF_TX_PCS0;
   \   00000010   0x2067             MOVS     R0,#+103
   \   00000012   0x....             LDR.N    R1,??DataTable9_8
   \   00000014   0x7408             STRB     R0,[R1, #+16]
    134          	SPI_InitStructure.SPI_SckPin = NRF_TX_SCK;
   \   00000016   0x2068             MOVS     R0,#+104
   \   00000018   0x....             LDR.N    R1,??DataTable9_8
   \   0000001A   0x7588             STRB     R0,[R1, #+22]
    135          	SPI_InitStructure.SPI_MosiPin = NRF_TX_MOSI;
   \   0000001C   0x2069             MOVS     R0,#+105
   \   0000001E   0x....             LDR.N    R1,??DataTable9_8
   \   00000020   0x75C8             STRB     R0,[R1, #+23]
    136          	SPI_InitStructure.SPI_MisoPin = NRF_TX_MISO;
   \   00000022   0x206A             MOVS     R0,#+106
   \   00000024   0x....             LDR.N    R1,??DataTable9_8
   \   00000026   0x7608             STRB     R0,[R1, #+24]
    137          
    138          	SPI_InitStructure.SPI_TxCompleteIntIsr = NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable9_8
   \   0000002C   0x61C8             STR      R0,[R1, #+28]
    139          	SPI_InitStructure.SPI_QueueEndIntIsr = NULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable9_8
   \   00000032   0x6208             STR      R0,[R1, #+32]
    140          	SPI_InitStructure.SPI_TxFIFO_FillIntIsr = NULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable9_8
   \   00000038   0x62C8             STR      R0,[R1, #+44]
    141          	SPI_InitStructure.SPI_TxFIFO_UnderflowIntIsr = NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable9_8
   \   0000003E   0x6248             STR      R0,[R1, #+36]
    142          	SPI_InitStructure.SPI_RxFIFO_DrainIntIsr = NULL;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x....             LDR.N    R1,??DataTable9_8
   \   00000044   0x6308             STR      R0,[R1, #+48]
    143          	SPI_InitStructure.SPI_RxFIFO_OverflowIntIsr = NULL;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable9_8
   \   0000004A   0x6288             STR      R0,[R1, #+40]
    144          
    145          	LPLD_SPI_Init(SPI_InitStructure);
   \   0000004C   0x....             LDR.N    R1,??DataTable9_8
   \   0000004E   0xB084             SUB      SP,SP,#+16
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x2234             MOVS     R2,#+52
   \   00000054   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000058   0xBC0F             POP      {R0-R3}
   \   0000005A   0x.... 0x....      BL       LPLD_SPI_Init
    146          
    147          	// 初始化发送模块CE
    148          	GPIO_InitStructure.GPIO_PTx = NRF_TX_CE_PTx;
   \   0000005E   0x....             LDR.N    R0,??DataTable9_9  ;; 0x400ff0c0
   \   00000060   0x....             LDR.N    R1,??DataTable9_10
   \   00000062   0x6008             STR      R0,[R1, #+0]
    149          	GPIO_InitStructure.GPIO_Pins = NRF_TX_CE_Pinx;
   \   00000064   0xF44F 0x6080      MOV      R0,#+1024
   \   00000068   0x....             LDR.N    R1,??DataTable9_10
   \   0000006A   0x6048             STR      R0,[R1, #+4]
    150          	GPIO_InitStructure.GPIO_Dir = DIR_OUTPUT;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x....             LDR.N    R1,??DataTable9_10
   \   00000070   0x7308             STRB     R0,[R1, #+12]
    151          	GPIO_InitStructure.GPIO_Output = OUTPUT_L;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR.N    R1,??DataTable9_10
   \   00000076   0x7348             STRB     R0,[R1, #+13]
    152          
    153          	LPLD_GPIO_Init(GPIO_InitStructure);
   \   00000078   0x....             LDR.N    R1,??DataTable9_10
   \   0000007A   0xB084             SUB      SP,SP,#+16
   \   0000007C   0x4668             MOV      R0,SP
   \   0000007E   0x2214             MOVS     R2,#+20
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000084   0xBC0F             POP      {R0-R3}
   \   00000086   0x.... 0x....      BL       LPLD_GPIO_Init
    154          
    155          	// 初始化接收模块SPI
    156          	SPI_InitStructure.SPI_SPIx = NRF_RX_SPIx;
   \   0000008A   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000008C   0x....             LDR.N    R1,??DataTable9_8
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    157          	SPI_InitStructure.SPI_SckDivider = SPI_SCK_DIV_32;
   \   00000090   0x2005             MOVS     R0,#+5
   \   00000092   0x....             LDR.N    R1,??DataTable9_8
   \   00000094   0x7148             STRB     R0,[R1, #+5]
    158          	SPI_InitStructure.SPI_Pcs0Pin = NRF_RX_PCS0;
   \   00000096   0x200E             MOVS     R0,#+14
   \   00000098   0x....             LDR.N    R1,??DataTable9_8
   \   0000009A   0x7408             STRB     R0,[R1, #+16]
    159          	SPI_InitStructure.SPI_SckPin = NRF_RX_SCK;
   \   0000009C   0x200F             MOVS     R0,#+15
   \   0000009E   0x....             LDR.N    R1,??DataTable9_8
   \   000000A0   0x7588             STRB     R0,[R1, #+22]
    160          	SPI_InitStructure.SPI_MosiPin = NRF_RX_MOSI;
   \   000000A2   0x2010             MOVS     R0,#+16
   \   000000A4   0x....             LDR.N    R1,??DataTable9_8
   \   000000A6   0x75C8             STRB     R0,[R1, #+23]
    161          	SPI_InitStructure.SPI_MisoPin = NRF_RX_MISO;
   \   000000A8   0x2011             MOVS     R0,#+17
   \   000000AA   0x....             LDR.N    R1,??DataTable9_8
   \   000000AC   0x7608             STRB     R0,[R1, #+24]
    162          
    163          	LPLD_SPI_Init(SPI_InitStructure);
   \   000000AE   0x....             LDR.N    R1,??DataTable9_8
   \   000000B0   0xB084             SUB      SP,SP,#+16
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x2234             MOVS     R2,#+52
   \   000000B6   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000BA   0xBC0F             POP      {R0-R3}
   \   000000BC   0x.... 0x....      BL       LPLD_SPI_Init
    164          
    165          	// 初始化接收模块CE
    166          	GPIO_InitStructure.GPIO_PTx = NRF_RX_CE_PTx;
   \   000000C0   0x....             LDR.N    R0,??DataTable9_11  ;; 0x400ff000
   \   000000C2   0x....             LDR.N    R1,??DataTable9_10
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    167          	GPIO_InitStructure.GPIO_Pins = NRF_RX_CE_Pinx;
   \   000000C6   0xF44F 0x5000      MOV      R0,#+8192
   \   000000CA   0x....             LDR.N    R1,??DataTable9_10
   \   000000CC   0x6048             STR      R0,[R1, #+4]
    168          	GPIO_InitStructure.GPIO_Dir = DIR_OUTPUT;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x....             LDR.N    R1,??DataTable9_10
   \   000000D2   0x7308             STRB     R0,[R1, #+12]
    169          	GPIO_InitStructure.GPIO_Output = OUTPUT_L;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x....             LDR.N    R1,??DataTable9_10
   \   000000D8   0x7348             STRB     R0,[R1, #+13]
    170          
    171          	LPLD_GPIO_Init(GPIO_InitStructure);
   \   000000DA   0x....             LDR.N    R1,??DataTable9_10
   \   000000DC   0xB084             SUB      SP,SP,#+16
   \   000000DE   0x4668             MOV      R0,SP
   \   000000E0   0x2214             MOVS     R2,#+20
   \   000000E2   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000E6   0xBC0F             POP      {R0-R3}
   \   000000E8   0x.... 0x....      BL       LPLD_GPIO_Init
    172          }
   \   000000EC   0xB009             ADD      SP,SP,#+36
   \   000000EE   0xBD00             POP      {PC}             ;; return

   \                                 In section .bss, align 4
   \                     ??SPI_InitStructure:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
   \                     ??GPIO_InitStructure:
   \   00000000                      DS8 20
    173          

   \                                 In section .text, align 2, keep-with-next
    174          static uint8 NRF_TX_Init(void)
    175          {
   \                     NRF_TX_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    176          	uint8 Temp;
    177          
    178          	NRF_TX_CE_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe1828
   \   00000006   0x6008             STR      R0,[R1, #+0]
    179          	// 芯片上电复位后
    180          	// 分别读取NRF24L01_RX_ADDR_P0、NRF24L01_RX_ADDR_P1、NRF24L01_TX_ADDR的值
    181          	// 查看以下数据
    182          	// NRF24L01_RX_ADDR_P0的复位值是否为0xE7E7E7E7
    183          	// NRF24L01_RX_ADDR_P1的复位值是否为0xC2C2C2C2
    184          	// NRF24L01_TX_ADDR的复位值是否为0xE7E7E7E7
    185          	// 如果正确证明SPI读写没有问题，反之亦然
    186          	LPLD_NRF_CheckID(NRF_TX_SPIx);
   \   00000008   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   0000000A   0x.... 0x....      BL       LPLD_NRF_CheckID
    187          
    188          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_FLUSE_TX, 0xFF);
   \   0000000E   0x22FF             MOVS     R2,#+255
   \   00000010   0x21E1             MOVS     R1,#+225
   \   00000012   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   00000014   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000018   0x0004             MOVS     R4,R0
    189          
    190          	Temp = LPLD_NRF_WriteBuf(NRF_TX_SPIx, NRF_WRITE_REG + NRF_TX_ADDR, TX_ADDRESS, NRF_TX_ADR_LEN);
   \   0000001A   0x2305             MOVS     R3,#+5
   \   0000001C   0x....             LDR.N    R2,??DataTable9_3
   \   0000001E   0x2130             MOVS     R1,#+48
   \   00000020   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   00000022   0x.... 0x....      BL       LPLD_NRF_WriteBuf
   \   00000026   0x0004             MOVS     R4,R0
    191          
    192          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_EN_AA, 0x01);       //频道0自动,ACK应答允许
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x2121             MOVS     R1,#+33
   \   0000002C   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   0000002E   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000032   0x0004             MOVS     R4,R0
    193          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_EN_RXADDR, 0x01);   //允许接收地址只有频道0
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2122             MOVS     R1,#+34
   \   00000038   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   0000003A   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000003E   0x0004             MOVS     R4,R0
    194          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_SETUP_RETR, 0x1a);  //设置自动重发时间和次数：500us + 86us, 10 retrans...
   \   00000040   0x221A             MOVS     R2,#+26
   \   00000042   0x2124             MOVS     R1,#+36
   \   00000044   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   00000046   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000004A   0x0004             MOVS     R4,R0
    195          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_RF_CH, NRF_TX_CH);  //设置信道工作为2.4GHZ，收发必须一致
   \   0000004C   0x2263             MOVS     R2,#+99
   \   0000004E   0x2125             MOVS     R1,#+37
   \   00000050   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   00000052   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000056   0x0004             MOVS     R4,R0
    196          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_RF_SETUP, 0x07);    //设置发射速率为2MHZ，发射功率为最大值0dB
   \   00000058   0x2207             MOVS     R2,#+7
   \   0000005A   0x2126             MOVS     R1,#+38
   \   0000005C   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   0000005E   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000062   0x0004             MOVS     R4,R0
    197          	Temp = LPLD_NRF_WriteReg(NRF_TX_SPIx, NRF_WRITE_REG + NRF_CONFIG, 0x0E);      //使能CRC校验，使能TX，并且上电
   \   00000064   0x220E             MOVS     R2,#+14
   \   00000066   0x2120             MOVS     R1,#+32
   \   00000068   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ac000
   \   0000006A   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000006E   0x0004             MOVS     R4,R0
    198          
    199          	NRF_TX_CE_H();
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe1828
   \   00000074   0x6008             STR      R0,[R1, #+0]
    200          
    201          	Nrf24L01_DelayUs(2000); //等待Nrf24L01发送模式初始化完毕
   \   00000076   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000007A   0x.... 0x....      BL       Nrf24L01_DelayUs
    202          
    203          	return Temp;
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          static uint8 NRF_RX_Init(void)
    207          {
   \                     NRF_RX_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    208          	uint8 Temp;
    209          
    210          	NRF_RX_CE_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable9_12  ;; 0x43fe0034
   \   00000006   0x6008             STR      R0,[R1, #+0]
    211          	// 芯片上电复位后
    212          	// 分别读取NRF24L01_RX_ADDR_P0、NRF24L01_RX_ADDR_P1、NRF24L01_TX_ADDR的值
    213          	// 查看以下数据
    214          	// NRF24L01_RX_ADDR_P0的复位值是否为0xE7E7E7E7
    215          	// NRF24L01_RX_ADDR_P1的复位值是否为0xC2C2C2C2
    216          	// NRF24L01_TX_ADDR的复位值是否为0xE7E7E7E7
    217          	// 如果正确证明SPI读写没有问题，反之亦然
    218          	LPLD_NRF_CheckID(NRF_RX_SPIx);
   \   00000008   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000000A   0x.... 0x....      BL       LPLD_NRF_CheckID
    219          
    220          	Temp = LPLD_NRF_WriteBuf(NRF_RX_SPIx, NRF_WRITE_REG + NRF_RX_ADDR_P0, RX_ADDRESS, NRF_RX_ADR_LEN);
   \   0000000E   0x2305             MOVS     R3,#+5
   \   00000010   0x....             LDR.N    R2,??DataTable9_13
   \   00000012   0x212A             MOVS     R1,#+42
   \   00000014   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   00000016   0x.... 0x....      BL       LPLD_NRF_WriteBuf
   \   0000001A   0x0004             MOVS     R4,R0
    221          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_RX_PW_P0, NRF_PLOAD_LEN);
   \   0000001C   0x2220             MOVS     R2,#+32
   \   0000001E   0x2131             MOVS     R1,#+49
   \   00000020   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   00000022   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000026   0x0004             MOVS     R4,R0
    222          
    223          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_EN_AA, 0x01);      //频道0自动,ACK应答允许
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x2121             MOVS     R1,#+33
   \   0000002C   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000002E   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000032   0x0004             MOVS     R4,R0
    224          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_EN_RXADDR, 0x01);  //允许接收地址只有频道0
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2122             MOVS     R1,#+34
   \   00000038   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000003A   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000003E   0x0004             MOVS     R4,R0
    225          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_SETUP_RETR, 0x1a); // 500us + 86us, 10 retrans...
   \   00000040   0x221A             MOVS     R2,#+26
   \   00000042   0x2124             MOVS     R1,#+36
   \   00000044   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   00000046   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000004A   0x0004             MOVS     R4,R0
    226          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_RF_CH, NRF_RX_CH); //设置信道工作为2.4GHZ，收发必须一致
   \   0000004C   0x2228             MOVS     R2,#+40
   \   0000004E   0x2125             MOVS     R1,#+37
   \   00000050   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   00000052   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000056   0x0004             MOVS     R4,R0
    227          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_RF_SETUP, 0x07);   //设置发射速率为2MHZ，发射功率为最大值0dB
   \   00000058   0x2207             MOVS     R2,#+7
   \   0000005A   0x2126             MOVS     R1,#+38
   \   0000005C   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000005E   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   00000062   0x0004             MOVS     R4,R0
    228          	Temp = LPLD_NRF_WriteReg(NRF_RX_SPIx, NRF_WRITE_REG + NRF_CONFIG, 0x0F);     //使能CRC校验，使能RX，并且上电
   \   00000064   0x220F             MOVS     R2,#+15
   \   00000066   0x2120             MOVS     R1,#+32
   \   00000068   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4002c000
   \   0000006A   0x.... 0x....      BL       LPLD_NRF_WriteReg
   \   0000006E   0x0004             MOVS     R4,R0
    229          
    230          	NRF_RX_CE_H();
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x....             LDR.N    R1,??DataTable9_12  ;; 0x43fe0034
   \   00000074   0x6008             STR      R0,[R1, #+0]
    231          
    232          	Nrf24L01_DelayUs(2000);//等待Nrf24L01接收模式初始化完毕
   \   00000076   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000007A   0x.... 0x....      BL       Nrf24L01_DelayUs
    233          
    234          	return Temp;
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void NRF_Init(void)
    238          {
   \                     NRF_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    239          	NRF_SPI_Init();
   \   00000002   0x.... 0x....      BL       NRF_SPI_Init
    240          
    241          	NRF_TX_Init();
   \   00000006   0x.... 0x....      BL       NRF_TX_Init
    242          
    243          	static NVIC_InitTypeDef NVIC_InitStructure;
    244          	static GPIO_InitTypeDef GPIO_InitStructure;
    245          
    246          	NVIC_InitStructure.NVIC_IRQChannel = NRF_RX_IRQn;
   \   0000000A   0x2057             MOVS     R0,#+87
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    247          	NVIC_InitStructure.NVIC_IRQChannelGroupPriority = NVIC_PriorityGroup_2;
   \   00000010   0x2005             MOVS     R0,#+5
   \   00000012   0x....             LDR.N    R1,??DataTable9_14
   \   00000014   0x6048             STR      R0,[R1, #+4]
    248          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x....             LDR.N    R1,??DataTable9_14
   \   0000001A   0x6088             STR      R0,[R1, #+8]
    249          	NVIC_InitStructure.NVIC_IRQChannelSubPriority=3;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x....             LDR.N    R1,??DataTable9_14
   \   00000020   0x60C8             STR      R0,[R1, #+12]
    250          	NVIC_InitStructure.NVIC_IRQChannelEnable=0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable9_14
   \   00000026   0x7408             STRB     R0,[R1, #+16]
    251          	LPLD_NVIC_Init(NVIC_InitStructure);
   \   00000028   0x....             LDR.N    R1,??DataTable9_14
   \   0000002A   0xB084             SUB      SP,SP,#+16
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000034   0xBC0F             POP      {R0-R3}
   \   00000036   0x.... 0x....      BL       LPLD_NVIC_Init
    252          
    253          	GPIO_InitStructure.GPIO_PTx = NRF_RX_IRQ_PTx;
   \   0000003A   0x....             LDR.N    R0,??DataTable9_11  ;; 0x400ff000
   \   0000003C   0x....             LDR.N    R1,??DataTable9_15
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    254          	GPIO_InitStructure.GPIO_Pins = NRF_RX_IRQ_Pinx;
   \   00000040   0xF44F 0x6080      MOV      R0,#+1024
   \   00000044   0x....             LDR.N    R1,??DataTable9_15
   \   00000046   0x6048             STR      R0,[R1, #+4]
    255          	GPIO_InitStructure.GPIO_Dir = DIR_INPUT;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable9_15
   \   0000004C   0x7308             STRB     R0,[R1, #+12]
    256          	GPIO_InitStructure.GPIO_PinControl =  INPUT_PULL_DOWN | IRQC_FA;
   \   0000004E   0x....             LDR.N    R0,??DataTable9_16  ;; 0xa0002
   \   00000050   0x....             LDR.N    R1,??DataTable9_15
   \   00000052   0x6088             STR      R0,[R1, #+8]
    257          	GPIO_InitStructure.GPIO_Isr = NRF_isr;
   \   00000054   0x....             LDR.N    R0,??DataTable9_17
   \   00000056   0x....             LDR.N    R1,??DataTable9_15
   \   00000058   0x6108             STR      R0,[R1, #+16]
    258          
    259          	LPLD_GPIO_Init(GPIO_InitStructure);
   \   0000005A   0x....             LDR.N    R1,??DataTable9_15
   \   0000005C   0xB084             SUB      SP,SP,#+16
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x2214             MOVS     R2,#+20
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000066   0xBC0F             POP      {R0-R3}
   \   00000068   0x.... 0x....      BL       LPLD_GPIO_Init
    260          	LPLD_GPIO_EnableIrq(GPIO_InitStructure);
   \   0000006C   0x....             LDR.N    R1,??DataTable9_15
   \   0000006E   0xB084             SUB      SP,SP,#+16
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x2214             MOVS     R2,#+20
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000078   0xBC0F             POP      {R0-R3}
   \   0000007A   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
    261          
    262          	NRF_RX_Init();
   \   0000007E   0x.... 0x....      BL       NRF_RX_Init
    263          }
   \   00000082   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??NVIC_InitStructure:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \                     ??GPIO_InitStructure_1:
   \   00000000                      DS8 20
    264          

   \                                 In section .text, align 4, keep-with-next
    265          static uint8 LPLD_NRF_CheckID(SPI_Type *spix)
    266          {
   \                     LPLD_NRF_CheckID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    267          	uint8 Temp;
    268          	if (spix == NRF_TX_SPIx)
   \   00000004   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ac000
   \   00000006   0x428C             CMP      R4,R1
   \   00000008   0xD115             BNE.N    ??LPLD_NRF_CheckID_0
    269          	{
    270          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_RX_ADDR_P1, NRF_RX_ADDR_P1_RESET_BUF1, 5);
   \   0000000A   0x2305             MOVS     R3,#+5
   \   0000000C   0x....             LDR.N    R2,??DataTable9_18
   \   0000000E   0x210B             MOVS     R1,#+11
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    271          		asm("nop");
   \   00000016   0xBF00             nop
    272          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_TX_ADDR, NRF_TX_ADDR_RESET_BUF1, 5);
   \   00000018   0x2305             MOVS     R3,#+5
   \   0000001A   0x....             LDR.N    R2,??DataTable9_19
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    273          		asm("nop");
   \   00000024   0xBF00             nop
    274          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_RX_ADDR_P0, NRF_RX_ADDR_P0_RESET_BUF1, 5);
   \   00000026   0x2305             MOVS     R3,#+5
   \   00000028   0x....             LDR.N    R2,??DataTable9_20
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    275          		asm("nop");
   \   00000032   0xBF00             nop
   \   00000034   0xE017             B.N      ??LPLD_NRF_CheckID_1
    276          	}
    277          	else if (spix == NRF_RX_SPIx)
   \                     ??LPLD_NRF_CheckID_0: (+1)
   \   00000036   0x....             LDR.N    R1,??DataTable9_5  ;; 0x4002c000
   \   00000038   0x428C             CMP      R4,R1
   \   0000003A   0xD114             BNE.N    ??LPLD_NRF_CheckID_1
    278          	{
    279          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_RX_ADDR_P1, NRF_RX_ADDR_P1_RESET_BUF2, 5);
   \   0000003C   0x2305             MOVS     R3,#+5
   \   0000003E   0x....             LDR.N    R2,??DataTable9_21
   \   00000040   0x210B             MOVS     R1,#+11
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    280          		asm("nop");
   \   00000048   0xBF00             nop
    281          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_TX_ADDR, NRF_TX_ADDR_RESET_BUF2, 5);
   \   0000004A   0x2305             MOVS     R3,#+5
   \   0000004C   0x....             LDR.N    R2,??DataTable9_22
   \   0000004E   0x2110             MOVS     R1,#+16
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    282          		asm("nop");
   \   00000056   0xBF00             nop
    283          		Temp = LPLD_NRF_ReadBuf(spix, NRF_READ_REG + NRF_RX_ADDR_P0, NRF_RX_ADDR_P0_RESET_BUF2, 5);
   \   00000058   0x2305             MOVS     R3,#+5
   \   0000005A   0x....             LDR.N    R2,??DataTable9_23
   \   0000005C   0x210A             MOVS     R1,#+10
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       LPLD_NRF_ReadBuf
    284          		asm("nop");
   \   00000064   0xBF00             nop
    285          	}
    286          	return Temp;
   \                     ??LPLD_NRF_CheckID_1: (+1)
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
    287          }
    288          

   \                                 In section .text, align 2, keep-with-next
    289          static uint8 LPLD_NRF_WriteBuf(SPI_Type *spix, uint8 reg, uint8 *pbuf, uint8 len)
    290          {
   \                     LPLD_NRF_WriteBuf: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    291          	uint8 status, i;
    292          
    293          	status = LPLD_SPI_Master_WriteRead(spix, reg, SPI_PCS0, SPI_PCS_ASSERTED); //帧发送完毕后PCS保持低电平
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   00000016   0x0007             MOVS     R7,R0
    294          
    295          	for (i = 0; i < len; i++)
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   \   0000001C   0xE008             B.N      ??LPLD_NRF_WriteBuf_0
    296          	{
    297          		if (i == (len - 1))
    298          		{
    299          			LPLD_SPI_Master_WriteRead(spix, *pbuf++, SPI_PCS0, SPI_PCS_INACTIVE);//帧发送完毕后PCS变成高电平
    300          		}
    301          		else
    302          		{
    303          			LPLD_SPI_Master_WriteRead(spix, *pbuf++, SPI_PCS0, SPI_PCS_ASSERTED);
   \                     ??LPLD_NRF_WriteBuf_1: (+1)
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x7829             LDRB     R1,[R5, #+0]
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
    304          		}
   \                     ??LPLD_NRF_WriteBuf_2: (+1)
   \   0000002C   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??LPLD_NRF_WriteBuf_0: (+1)
   \   00000030   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x45B0             CMP      R8,R6
   \   00000038   0xD20D             BCS.N    ??LPLD_NRF_WriteBuf_3
   \   0000003A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x1E70             SUBS     R0,R6,#+1
   \   00000042   0x4580             CMP      R8,R0
   \   00000044   0xD1EB             BNE.N    ??LPLD_NRF_WriteBuf_1
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x7829             LDRB     R1,[R5, #+0]
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
   \   00000054   0xE7EA             B.N      ??LPLD_NRF_WriteBuf_2
    305          	}
    306          	return status;
   \                     ??LPLD_NRF_WriteBuf_3: (+1)
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    307          }
    308          

   \                                 In section .text, align 2, keep-with-next
    309          static uint8 LPLD_NRF_ReadBuf(SPI_Type *spix, uint8 reg, uint8 *pbuf, uint8 len)
    310          {
   \                     LPLD_NRF_ReadBuf: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    311          	uint8 Status,i;
    312          
    313          	Status = LPLD_SPI_Master_WriteRead(spix, reg, SPI_PCS0, SPI_PCS_ASSERTED);
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   00000016   0x0007             MOVS     R7,R0
    314          
    315          	for (i = 0; i < len; i++)
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   \   0000001C   0xE00B             B.N      ??LPLD_NRF_ReadBuf_0
    316          	{
    317          		if (i == (len - 1))
    318          		{
    319          			pbuf[i] = LPLD_SPI_Master_WriteRead(spix, 0xFF, SPI_PCS0, SPI_PCS_INACTIVE);
    320          		}
    321          		else
    322          		{
    323          			pbuf[i] = LPLD_SPI_Master_WriteRead(spix, 0xFF, SPI_PCS0, SPI_PCS_ASSERTED);
   \                     ??LPLD_NRF_ReadBuf_1: (+1)
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x21FF             MOVS     R1,#+255
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   0000002A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002E   0xF808 0x0005      STRB     R0,[R8, R5]
    324          		}
   \                     ??LPLD_NRF_ReadBuf_2: (+1)
   \   00000032   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??LPLD_NRF_ReadBuf_0: (+1)
   \   00000036   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x45B0             CMP      R8,R6
   \   0000003E   0xD210             BCS.N    ??LPLD_NRF_ReadBuf_3
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x1E70             SUBS     R0,R6,#+1
   \   00000048   0x4580             CMP      R8,R0
   \   0000004A   0xD1E8             BNE.N    ??LPLD_NRF_ReadBuf_1
   \   0000004C   0x2300             MOVS     R3,#+0
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0x21FF             MOVS     R1,#+255
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF808 0x0005      STRB     R0,[R8, R5]
   \   00000060   0xE7E7             B.N      ??LPLD_NRF_ReadBuf_2
    325          	}
    326          	return Status ;
   \                     ??LPLD_NRF_ReadBuf_3: (+1)
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          static uint8 LPLD_NRF_WriteReg(SPI_Type *spix, uint8 reg, uint8 value)
    330          {
   \                     LPLD_NRF_WriteReg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    331          	uint8 Status;
    332          	Status = LPLD_SPI_Master_WriteRead(spix, reg, SPI_PCS0, SPI_PCS_ASSERTED);
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
   \   00000012   0x0006             MOVS     R6,R0
    333          	LPLD_SPI_Master_WriteRead(spix, value, SPI_PCS0, SPI_PCS_INACTIVE);
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
    334          	return Status;
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    335          }
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static uint8 LPLD_NRF_ReadReg(SPI_Type *spix, uint8 reg)
    338          {
   \                     LPLD_NRF_ReadReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    339          	uint8 temp;
    340          	LPLD_SPI_Master_WriteRead(spix, reg, SPI_PCS0, SPI_PCS_ASSERTED);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
    341          	temp = LPLD_SPI_Master_WriteRead(spix, 0xFF, SPI_PCS0, SPI_PCS_INACTIVE);
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       LPLD_SPI_Master_WriteRead
    342          	return temp;
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    343          }
    344          

   \                                 In section .text, align 4, keep-with-next
    345          static void Nrf24L01_DelayUs(uint16 t)
    346          {
    347          	uint16 i;
    348          	for(i = 0; i < t;i++)
   \                     Nrf24L01_DelayUs: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??Nrf24L01_DelayUs_0
    349          	{
    350          		asm("nop");
   \                     ??Nrf24L01_DelayUs_1: (+1)
   \   00000004   0xBF00             nop
    351          	}
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \                     ??Nrf24L01_DelayUs_0: (+1)
   \   00000008   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xD3F9             BCC.N    ??Nrf24L01_DelayUs_1
    352          }
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     nrf+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x43FE1828         DC32     0x43fe1828

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     TX_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400AC000         DC32     0x400ac000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4002C000         DC32     0x4002c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     nrf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     nrf+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ??SPI_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ??GPIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x43FE0034         DC32     0x43fe0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     RX_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     ??NVIC_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     ??GPIO_InitStructure_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x000A0002         DC32     0xa0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     NRF_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x........         DC32     NRF_RX_ADDR_P1_RESET_BUF1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     NRF_TX_ADDR_RESET_BUF1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     NRF_RX_ADDR_P0_RESET_BUF1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     NRF_RX_ADDR_P1_RESET_BUF2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     NRF_TX_ADDR_RESET_BUF2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     NRF_RX_ADDR_P0_RESET_BUF2

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   LPLD_NRF_CheckID
         8   -> LPLD_NRF_ReadBuf
      16   LPLD_NRF_RX_RecvFrame
        16   -> LPLD_NRF_ReadBuf
        16   -> LPLD_NRF_ReadReg
        16   -> LPLD_NRF_WriteReg
      24   LPLD_NRF_ReadBuf
        24   -> LPLD_SPI_Master_WriteRead
       8   LPLD_NRF_ReadReg
         8   -> LPLD_SPI_Master_WriteRead
      16   LPLD_NRF_TX_SendFrame
        16   -> LPLD_NRF_ReadReg
        16   -> LPLD_NRF_WriteBuf
        16   -> LPLD_NRF_WriteReg
        16   -> LPLD_SYSTICK_DelayUs
      24   LPLD_NRF_WriteBuf
        24   -> LPLD_SPI_Master_WriteRead
      16   LPLD_NRF_WriteReg
        16   -> LPLD_SPI_Master_WriteRead
      24   NRF_Init
         8   -> LPLD_GPIO_EnableIrq
         8   -> LPLD_GPIO_Init
         8   -> LPLD_NVIC_Init
         8   -> NRF_RX_Init
         8   -> NRF_SPI_Init
         8   -> NRF_TX_Init
        24   -> __aeabi_memcpy4
       8   NRF_RX_Init
         8   -> LPLD_NRF_CheckID
         8   -> LPLD_NRF_WriteBuf
         8   -> LPLD_NRF_WriteReg
         8   -> Nrf24L01_DelayUs
      56   NRF_SPI_Init
        40   -> LPLD_GPIO_Init
        40   -> LPLD_SPI_Init
        56   -> __aeabi_memcpy4
       8   NRF_Send
         8   -> LPLD_NRF_TX_SendFrame
       0   NRF_Set
       8   NRF_TX_Init
         8   -> LPLD_NRF_CheckID
         8   -> LPLD_NRF_WriteBuf
         8   -> LPLD_NRF_WriteReg
         8   -> Nrf24L01_DelayUs
       8   NRF_isr
         8   -> LPLD_NRF_RX_RecvFrame
       0   Nrf24L01_DelayUs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      20  GPIO_InitStructure
      20  GPIO_InitStructure
     106  LPLD_NRF_CheckID
      48  LPLD_NRF_RX_RecvFrame
     106  LPLD_NRF_ReadBuf
      32  LPLD_NRF_ReadReg
     142  LPLD_NRF_TX_SendFrame
      94  LPLD_NRF_WriteBuf
      40  LPLD_NRF_WriteReg
     132  NRF_Init
       8  NRF_RX_ADDR_P0_RESET_BUF1
       8  NRF_RX_ADDR_P0_RESET_BUF2
       8  NRF_RX_ADDR_P1_RESET_BUF1
       8  NRF_RX_ADDR_P1_RESET_BUF2
     132  NRF_RX_Init
     240  NRF_SPI_Init
      12  NRF_Send
      18  NRF_Set
       8  NRF_TX_ADDR_RESET_BUF1
       8  NRF_TX_ADDR_RESET_BUF2
     132  NRF_TX_Init
      24  NRF_isr
      20  NVIC_InitStructure
      18  Nrf24L01_DelayUs
       8  RX_ADDRESS
      52  SPI_InitStructure
       8  TX_ADDRESS
      76  nrf

 
   160 bytes in section .bss
    92 bytes in section .data
 1 372 bytes in section .text
 
 1 372 bytes of CODE memory
   252 bytes of DATA memory

Errors: none
Warnings: none
